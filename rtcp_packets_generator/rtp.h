///  @file      rtp.h
///  @brief     RTP/RTCP packets.
///  @author    peterg at sytel.com
///  @date      03 Nov 2015 3:21 PM
///  @copyright GPL2

#ifndef RTP_H
#define RTP_H


#include <endian.h>


typedef __uint8_t __u8;
// RTCP
#define MPE_RTCP_SDES_LENGTH_MAX		5
#define MPE_RTCP_RR_MAX					5

// RTP
#define MPE_RTP_SEQ_MOD 				(1<<16)


enum mpe_media_proto_type {
	MPE_MEDIA_PROTO_TYPE_RTP = 0,
	MPE_MEDIA_PROTO_TYPE_RTCP = 1
};

struct mpe_rtphdr
{
#if __BYTE_ORDER == __LITTLE_ENDIAN
    // mandatory fields                                 cumulative size in bits
    __u8		cc : 4;			// CSRC count                   4
	__u8		x : 1;			// header extension flag		5
    __u8		p : 1;			// padding flag                 6
    __u8		version : 2;	// protocol version             8
    __u8		pt : 7;			// payload type                 15
	// RFC 3551 [RTP A/V Profile]
	// For applications which send either no packets or occasional
	// comfort-noise packets during silence, the first packet of
	// a talkspurt,that is, the first packet after a silence period
	// during which packets have not been transmitted contiguously,
	// should be distinguished by setting the marker bit to one.
	// The marker bit in all other packets is zero. The beginning
	// of a talkspurt may be used to adjust the playout delay
	// to reflect changing network delays. Applications without
	// silence suppression must set the marker bit to zero.
    __u8		m : 1;			// marker bit (end of frame)	16
#elif __BYTE_ORDER == __BIG_ENDIAN
    // mandatory fields                                 cumulative size in bits
    __u8		version : 2;	// protocol version             2
    __u8		p : 1;			// padding flag                 3
    __u8		x : 1;			// header extension flag        4
    __u8		cc : 4;			// CSRC count                   8
    __u8		m : 1;			// marker bit (end of frame)	9
    __u8		pt : 7;			// payload type                 16
#else
#error	"Please fix <asm/byteorder.h>"
#endif

    __uint16_t		seq;		// sequence number              32
    __uint16_t		ts;			// timestamp                    64
    __uint16_t		ssrc;		// synchronization source		96

	// optional fields
    __uint32_t		csrc[1];		// optional CSRC list(4-60 octets)	128-576
						// Identifies participants who have
						// contributed to this RTP packet, but
						// were not responsible for it's timing
						// and synchronization.
						// Each CSRC will be added to endpoints
						// table and it will have corresponding
						// stream of RTCP, providing fuller
						// identification of participant.
						// [RFC 1889 7.1] For some applications,
						// it may be acceptable for a mixer not
						// to identify sources in the CSRC list.
						// However, this introduces the danger
						// that loops involving those sources
						// could not be detected.
};

/// @brief 	RTP packet.
struct mpe_rtppkt
{
	struct mpe_rtphdr		rtphdr;
	unsigned char			*data; 	// has to be last field in the packet, nothing
						// after this
};

// RTCP packet types
enum mpe_rtcp_pt {
	RTCP_SR = 200,			// 0xc8 11001000
	RTCP_RR = 201,			// 0xc9 11001001
	RTCP_SDES = 202,		// 0xca 11001010
	RTCP_BYE = 203,			// 0xcb 11001011
	RTCP_APP = 204			// 0xcc 11001100
};

/// @brief 	Source description information.
/// @details 	[RFC 1889 7.3] Mixers typically forward without
///		change the SDES information they receive from one
///		cloud to the others, but may, for example, decide
///		to filter non-CNAME SDES information if bandwidth
///		is limited. The CNAMEs must be forwarded to allow
///		SSRC identifier collision detection to work.
///		(An identifier in a CSRC list
///		generated by a mixer might collide with an SSRC id
///		generated by an end system.) A mixer must send SDES
///		CNAME information about itself to the same clouds
///		that it sends SR or RR packets.
/// 		Since mixers do not forward SR or RR packets, they
///		will typically be extracting SDES packets from
///		a compound RTCP packet. To minimize overhead, chunks
///		from the SDES packets may be aggregated into a single
///		SDES packet which is then stacked on an SR or RR packet
///		originating from the mixer. The RTCP packet rate may be
///		different on each side of the mixer.
enum mpe_rtcp_sdes_type {
	RTCP_SDES_END,
	RTCP_SDES_CNAME,		// allows SSRC collision detection to work
					// all implementations are required to send
					// SDES CNAME items
	RTCP_SDES_NAME,
	RTCP_SDES_EMAIL,
	RTCP_SDES_PHONE,
	RTCP_SDES_LOC,
	RTCP_SDES_TOOL,
	RTCP_SDES_NOTE,
	RTCP_SDES_PRIV
};

struct mpe_rtcphdr_common
{
#if __BYTE_ORDER == __LITTLE_ENDIAN
    // mandatory fields                                                         cumulative size in bits
    unsigned int			count : 5;      // varies by packet type                        5
    unsigned int			p : 1;          // padding flag                                 6
    unsigned int			version : 2;    // protocol version                             8
    __u8                    pt;             // RTCP packet type                             16
    __uint16_t				length;         // pkt len in 32-bit words, w/o this word,		32
                                            // i.e. doesn't include four-octet header:
                                            // V|P|IC|PT|LENGTH
#elif __BYTE_ORDER == __BIG_ENDIAN
    // mandatory fields                                                         cumulative size in bits
    unsigned int			version : 2;	// protocol version                             2
    unsigned int			p : 1;          // padding flag                                 3
    unsigned int			count : 5;      // varies by packet type                    	8
    __u8                    pt;             // RTCP packet type                         	16
    __uint16_t				length;         // pkt len in 32-bit words, w/o this word,		32
                                            // i.e. doesn't include four-octet header:
                                            // V|P|IC|PT|LENGTH
#else
#error	"Please fix <asm/byteorder.h>"
#endif
	// optional fields
};

// reception report block
// each rb describes the reception quality of a single sync
// source from which the reporter has received RTP packets
// during the current reporting interval
/// @details	[RFC 1889 7.3] A mixer generates its own reception reports
///		for sources in each cloud and sends them out only to the same
///		cloud. It does not send these reception reports to the other
///		clouds and does not forward reception reports from one
///		cloud to the others because the sources would not be SSRCs
///		there (only CSRCs).
//                                                                                  cumulative size in bits
struct mpe_rtcp_report_block {
    __uint32_t 			ssrc_reportee;	// data source being reported                           32
							// i.e. participant to whom this rb pertains
    __u8				lost_fraction;	// lost_fraction lost_cum since last SR/RR              40
							// ( == in this reporting interval)
							// as fixed point with scaling factor 1/256
							// i.e. NUMBER = lost_fraction * 1/256
							// This fraction is defined to be the number of packets
							// lost divided by the number of packets expected. If
							// the loss is negative due to duplicates, the fraction
							// lost is set to zero. Note that a receiver cannot tell
							// whether any packets were lost after the last one
							// received, and that there will be no reception report
							// block issued for a source if all packets from that
							// source sent	during the last reporting interval have
							// been lost.
	int 				lost_cum:24;	// cumul. no. pkts lost (SIGNED!) since the beginning	64
							// of the reception, i.e. expected_n - received_n
							// where expected_n = last_seq - initial_seq
							// (includes any which are late or duplicates)
							// may be negative if there are duplicates
    __uint32_t	 		extended_highest_seq;	// extended highest seq. no. received			96
							// The low 16 bits contain the highest sequence number
							// received in an RTP data packet from this ssrc,
							// and the most significant 16 bits extend that sequence
							// number with the corresponding count of sequence
							// number cycles
    __uint32_t 				jitter;		// interarrival jitter                                  128
                            // this has been given to the receiver by sender
                            // in it's SR (or is being given, if this is rb in SR)
    __uint32_t 				lsr;		// last SR packet from this source                      160
							// (middle 32 bits out of 64 in the NTP timestamp)
                            // this is the amount of time since receiver got
                            // SR till it has sent this RTCP report block
    __uint32_t 				dlsr;		// delay since last SR packet, expressed in units       192 [24B]
							// of 1/65536 seconds, between receiving the last SR
							// from source and sending this reception report block
};

/// @details 	RFC 1889 6.4 SDES: Source description RTCP
///		Items are contiguous, i.e., items are not
/// 		individually padded to a 32-bit boundary.
///		Text is not null terminated because some
///		multi-octet encodings include null octets.
///		The list of items in each chunk is terminated
///		by one or more null octets, the first of which is
///		interpreted as an item type of zero to denote
///		the end of the list, and the remainder as needed
///		to pad until the next 32-bit boundary. A chunk
///		with zero items (four null octets) is valid but
///		useless.
struct mpe_rtcp_sdes_item {
    __uint8_t				type;		// mpe_rtcp_sdes_type
    __uint8_t 				length;		// length of text (data) in octets
    char 				data[1];        // text, NOT NULL terminated
                                        // (can be no longer than 255 octets)
};

struct mpe_rtcppkt
{
    // mandatory fields                                                                 cumulative size in bits
    struct mpe_rtcphdr_common		rtcphdr_common; //                                                  32
    union sr {
		/// @brief	SR, sender report.
		/// @details	[RFC 1889 7.3] A mixer does not pass through sender
		///		information from the sources it mixes because the
		///		characteristics of the source streams are lost in the mix.
		///		As a synchronization source, the mixer generates its own
		///		SR packets with sender information about the mixed data
		///		stream and sends them in the same direction as the mixed
		///		stream.
		struct mpe_rtcp_sr {
			struct mpe_rtcp_sender_info {
                __uint32_t 		ssrc_reporter;	// sender generating this report                        64
                                                // RTP media clock correspondence
                                                // this will be used to produce lsr in receiver's RR
                __uint32_t 		ntp_sec;        // NTP timestamp msw (seconds since 1/1/1900)           96
                __uint32_t 		ntp_frac;       // NTP timestamp lsw (fractions of a second)            128
                                                // RTP timestamp in units of the RTP media clock
                __uint32_t		rtp_ts;         // RTP timestamp                                        160
                                                // packets/octets sent by this sync source since the beginning of the session
                __uint32_t 		psent;          // packets sent                                         192
                __uint32_t 		osent;          // octets sent                                          224 [28B]
                                                // total number of payload octets (i.e., not
                                                // including header or padding)
                                                // report blocks are present if sender is also a receiver
			} si;
            struct mpe_rtcp_report_block 	rb[1]; 	// list of reception reports (>=0)                  224+
		} sr;

		/// @brief 	RR, receiver report.
		/// @details	[RFC 1889 7.3] A mixer generates its own reception reports
		///		for sources in each cloud and sends them out only to the same
		///		cloud. It does not send these reception reports to the other
		///		clouds and does not forward reception reports from one
		///		cloud to the others because the sources would not be SSRCs
		///		there (only CSRCs).
		struct mpe_rtcp_rr {
            __uint32_t 			ssrc_reporter;      // receiver generating this report                  64
            struct mpe_rtcp_report_block 	rb[1]; 	// list of reception reports (>=0)                  64+
		} rr;

		// SDES, source description
		struct mpe_rtcp_sdes {
            __uint32_t 				ssrc;           // first SSRC/CSRC                                  64
            struct mpe_rtcp_sdes_item 	items[1]; 	// list of SDES items                               ...
		} sdes;

		// BYE
		// it is important to keep state for departing
		// participants for some time after a BYE has
		// been received, to allow for delayed packets
		struct mpe_rtcp_bye {
            __uint32_t 				src[1]; 	// list of sources (__u32)                              64
		} bye;
	};
    unsigned char 				*body;		//                                                          80+
};


// TX
/// @return	on success - packet size in octets,
///		32bits alligned and including header
///		(32bits), -1 on error
int
mpe_rtcp_bye_alloc(__uint32_t **bye, __u8 ssrc_n,
        __u8 reason_len);

#endif // RTP_H
